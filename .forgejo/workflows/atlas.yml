name: ATLAS

on:
  pull_request:

jobs:
  atlas:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Project
        uses: actions/checkout@v4
        with:
          clean: false
          path: ${{ github.event.repository.name }}
          token: ${{ secrets.MERGE_TOKEN }}

      - name: Checkout ATLAS
        uses: actions/checkout@v4
        with:
          repository: atlas/atlas-pipeline
          ref: master
          path: atlas-pipeline
          token: ${{ secrets.MERGE_TOKEN }}

      - name: Run ATLAS
        run: |
          set -eu

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            ATLAS_TRIGGER="pr"
          else
            ATLAS_TRIGGER="push"
          fi

          WORKSPACE_ROOT="${{ github.workspace }}"
          TARGET_REPO_NAME="${{ github.event.repository.name }}"
          TARGET_REPO_ROOT="$WORKSPACE_ROOT/$TARGET_REPO_NAME"
          ATLAS_REPO_ROOT="$WORKSPACE_ROOT/atlas-pipeline"
          ATLAS_LIB="$ATLAS_REPO_ROOT/src/lib"
          ATLAS_INC="$ATLAS_REPO_ROOT/src/inc"

          if [ -n "${PYTHONPATH:-}" ]; then
            export PYTHONPATH="$ATLAS_LIB:$ATLAS_INC:$PYTHONPATH"
          else
            export PYTHONPATH="$ATLAS_LIB:$ATLAS_INC"
          fi

          REQUIRED_REPOS_FILE="$WORKSPACE_ROOT/.atlas-required-repos.tsv"
          REQUIRED_SYSTEM_APT_FILE="$WORKSPACE_ROOT/.atlas-required-system-apt.tsv"
          python3 - "$TARGET_REPO_ROOT/.atlas/pipeline.xml" "$REQUIRED_REPOS_FILE" "$REQUIRED_SYSTEM_APT_FILE" "$ATLAS_LIB" "$ATLAS_INC" <<'PY'
          import sys
          from pathlib import Path

          pipeline_path = Path(sys.argv[1])
          required_repos_path = Path(sys.argv[2])
          required_system_apt_path = Path(sys.argv[3])
          atlas_lib = sys.argv[4]
          atlas_inc = sys.argv[5]

          # Keep imports deterministic even when target repos define config.py/model.py.
          sys.path.insert(0, atlas_inc)
          sys.path.insert(0, atlas_lib)

          from config import load_config

          config = load_config(pipeline_path)

          required_repos_raw = getattr(config.meta, "required_repos", [])
          required_system_apt_raw = getattr(config.meta, "required_system_apt", [])

          required_repo_lines: list[str] = []
          for required_repo in required_repos_raw:
              if isinstance(required_repo, str):
                  required_repo_name = required_repo.strip()
                  required_repo_ref = ""
              else:
                  required_repo_name = str(getattr(required_repo, "repository", "")).strip()
                  required_repo_ref = str(getattr(required_repo, "ref", "") or "").strip()
              if required_repo_name:
                  required_repo_lines.append(f"{required_repo_name}\t{required_repo_ref}\n")

          required_system_apt_lines: list[str] = []
          for required_apt in required_system_apt_raw:
              if isinstance(required_apt, str):
                  required_apt_package = required_apt.strip()
                  required_apt_version = ""
                  required_apt_options = ""
              else:
                  required_apt_package = str(getattr(required_apt, "package", "")).strip()
                  required_apt_version = str(getattr(required_apt, "version", "") or "").strip()
                  required_apt_options = str(getattr(required_apt, "options", "") or "").strip()
              if required_apt_package:
                  required_system_apt_lines.append(
                      f"{required_apt_package}\t{required_apt_version}\t{required_apt_options}\n"
                  )

          required_repos_path.write_text("".join(required_repo_lines), encoding="utf-8")
          required_system_apt_path.write_text("".join(required_system_apt_lines), encoding="utf-8")
          PY

          ORIGIN_URL="$(git -C "$TARGET_REPO_ROOT" remote get-url origin)"
          ORIGIN_AUTH_HEADER="$(git -C "$TARGET_REPO_ROOT" config --get-all "http.$ORIGIN_URL.extraheader" | head -n 1 || true)"
          if [ -z "$ORIGIN_AUTH_HEADER" ]; then
            ORIGIN_BASE_URL="$(python3 -c 'import sys; from urllib.parse import urlparse; parsed = urlparse(sys.argv[1]); print(f"{parsed.scheme}://{parsed.netloc}/" if parsed.scheme and parsed.netloc else "")' "$ORIGIN_URL")"
            if [ -n "$ORIGIN_BASE_URL" ]; then
              ORIGIN_AUTH_HEADER="$(git -C "$TARGET_REPO_ROOT" config --get-all "http.$ORIGIN_BASE_URL.extraheader" | head -n 1 || true)"
            fi
          fi

          if [ -s "$REQUIRED_SYSTEM_APT_FILE" ]; then
            if command -v sudo >/dev/null 2>&1; then
              APT_PREFIX=(sudo)
            elif [ "$(id -u)" -eq 0 ]; then
              APT_PREFIX=()
            else
              echo "atlas: error: required apt packages need elevated privileges (sudo not found and not running as root)" >&2
              exit 4
            fi

            "${APT_PREFIX[@]}" apt-get update
            while IFS="$(printf '\t')" read -r REQUIRED_APT_PACKAGE REQUIRED_APT_VERSION REQUIRED_APT_OPTIONS; do
              if [ -n "$REQUIRED_APT_VERSION" ]; then
                REQUIRED_APT_SPEC="${REQUIRED_APT_PACKAGE}=${REQUIRED_APT_VERSION}"
              else
                REQUIRED_APT_SPEC="$REQUIRED_APT_PACKAGE"
              fi

              APT_INSTALL_CMD=("${APT_PREFIX[@]}" apt-get install -y)
              if [ -n "$REQUIRED_APT_OPTIONS" ]; then
                read -r -a REQUIRED_APT_OPTIONS_ARRAY <<< "$REQUIRED_APT_OPTIONS"
                APT_INSTALL_CMD+=("${REQUIRED_APT_OPTIONS_ARRAY[@]}")
              fi
              APT_INSTALL_CMD+=("$REQUIRED_APT_SPEC")
              "${APT_INSTALL_CMD[@]}"
            done < "$REQUIRED_SYSTEM_APT_FILE"
          fi

          if [ -s "$REQUIRED_REPOS_FILE" ]; then
            while IFS="$(printf '\t')" read -r REQUIRED_REPO REQUIRED_REF; do
              REQUIRED_REPO_NAME="${REQUIRED_REPO##*/}"
              REQUIRED_REPO_ROOT="$WORKSPACE_ROOT/$REQUIRED_REPO_NAME"

              if [ "$REQUIRED_REPO_NAME" = "$TARGET_REPO_NAME" ]; then
                echo "atlas: config error: required repository '$REQUIRED_REPO' matches target repository" >&2
                exit 2
              fi

              REQUIRED_REPO_URL="$(python3 -c 'import sys; from urllib.parse import urlparse; origin_url = sys.argv[1].strip(); required_repo = sys.argv[2].strip().strip("/"); parsed = urlparse(origin_url); host_path = origin_url[4:] if origin_url.startswith("git@") else ""; host, sep, _ = host_path.partition(":") if host_path else ("", "", ""); print(f"git@{host}:{required_repo}.git" if sep else (f"{parsed.scheme}://{parsed.netloc}/{required_repo}.git" if parsed.scheme and parsed.netloc else ""))' "$ORIGIN_URL" "$REQUIRED_REPO")"

              if [ -z "$REQUIRED_REPO_URL" ]; then
                echo "atlas: error: unable to derive clone URL for required repository '$REQUIRED_REPO'" >&2
                exit 3
              fi

              if [ -d "$REQUIRED_REPO_ROOT/.git" ]; then
                echo "ATLAS: required repository already present: $REQUIRED_REPO_NAME"
                continue
              fi

              GIT_CLONE_CMD=(git -C "$TARGET_REPO_ROOT")
              if [ -n "$ORIGIN_AUTH_HEADER" ]; then
                GIT_CLONE_CMD+=(-c "http.extraheader=$ORIGIN_AUTH_HEADER")
              fi

              if [ -n "$REQUIRED_REF" ]; then
                "${GIT_CLONE_CMD[@]}" clone --depth 1 --branch "$REQUIRED_REF" "$REQUIRED_REPO_URL" "$REQUIRED_REPO_ROOT"
              else
                "${GIT_CLONE_CMD[@]}" clone --depth 1 "$REQUIRED_REPO_URL" "$REQUIRED_REPO_ROOT"
              fi
            done < "$REQUIRED_REPOS_FILE"
          fi

          cd "$TARGET_REPO_ROOT"

          python3 -m main --repo-root "$ATLAS_REPO_ROOT" validate
          python3 -m main --repo-root "$ATLAS_REPO_ROOT" run --trigger "$ATLAS_TRIGGER"

      - name: Upload ATLAS output
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: atlas-output-${{ github.run_id }}
          path: ${{ github.event.repository.name }}/bld/atlas/**
          if-no-files-found: warn
